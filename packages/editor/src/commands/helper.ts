import fs from 'fs'
import path from 'path'
import crypto from 'crypto'
import util from 'util'
import mkdirp from 'mkdirp'

import {ObjectMap, ServerPlugin} from '@karma.run/editor-common'
import {Configuration} from '../interface'

const Liftoff = require('liftoff')
const interpret = require('interpret')

const mkdirpPromise = util.promisify(mkdirp)

export interface LiftoffEnvironment {
  cwd: string
  require: string[]
  configNameSearch: string[]
  configPath: string
  configBase: string
  configFiles: string[]
  modulePackage: any
}

// Include .config in extensions
const extensions = Object.entries(interpret.jsVariants).reduce(
  (acc, [key, value]) => {
    acc[`.config${key}`] = value
    return acc
  },
  {} as ObjectMap<any>
)

export interface LoadConfigOptions {
  cwd?: string
  configPath?: string
  require?: string
}

export async function loadConfig(opts: LoadConfigOptions): Promise<Configuration> {
  return new Promise(resolve => {
    const configLoader = new Liftoff({
      name: 'karma.tools/editor',
      configName: 'editor', // Extension includes .config so full name is editor.config.*
      extensions: extensions
    })
      .on('require', (name: string) => {
        console.info('Preloading module:', name)
      })
      .on('requireFail', (name: string, err: Error) => {
        console.info('Unable to preload:', name, err)
      })

    configLoader.launch(
      {cwd: opts.cwd, configPath: opts.configPath, require: opts.require},
      (env: LiftoffEnvironment): void => {
        let config: Configuration = {}
        if (env.configPath) {
          const module = require(env.configPath)
          config = module.default || module
        }

        if (process.cwd() !== env.cwd) {
          process.chdir(env.cwd)
          console.info('Working directory changed to', env.cwd)
        }

        return resolve(config)
      }
    )
  })
}

export function loadPlugins(plugins: (ServerPlugin | string)[]): ServerPlugin[] {
  return plugins.map(plugin => {
    if (typeof plugin === 'string') {
      try {
        const module = require(plugin)

        if (typeof module === 'function') {
          return new module()
        }

        return new module.default()
      } catch (err) {
        return process.exit(1)
      }
    }

    return plugin
  })
}

export interface BuildOptions {
  plugins: ServerPlugin[]
}

export function getClientEntryData(opts: BuildOptions) {
  const clientModules = opts.plugins.map(plugin => plugin.clientModule)
  return `// THIS FILE IS AUTOGENERATED, EDIT WITH CAUTION
import {Editor} from '@karma.run/editor-client'

const editor = new Editor({
  plugins: [
    ${clientModules
      .map(module => `new (require(${JSON.stringify(module)}).default)()`)
      .join(',\n    ')}
  ]
})

editor.attach()`
}

export function getWorkerEntryData() {
  return `// THIS FILE IS AUTOGENERATED, EDIT WITH CAUTION
import '@karma.run/editor-worker'`
}

export function md5Hash(data: string) {
  return crypto
    .createHash('md5')
    .update(data)
    .digest('hex')
}

export function getBundleFilename(hash: string) {
  return `bundle.${hash}`
}

export function getEntryFilename(name: string, hash: string) {
  return `entry.${name}.${hash}`
}

export async function getCachedBuild(cachePath: string, opts: BuildOptions) {
  const entryData = getClientEntryData(opts)
  const bundlePath = path.resolve(cachePath, './', getBundleFilename(md5Hash(entryData)))

  try {
    await fs.promises.stat(bundlePath)
    return bundlePath
  } catch (err) {
    return undefined
  }
}

type WebpackStats = import('webpack').Stats
export type BuildResult = {stats: WebpackStats; path: string}

export async function build(
  cachePath: string,
  opts: BuildOptions,
  onProgress?: (percentage: number, msg: string) => void
) {
  return new Promise<BuildResult>(async (resolve, reject) => {
    let webpack: typeof import('webpack')

    try {
      webpack = (await import('webpack')).default
    } catch (err) {
      throw new Error("Coulnd't load webpack")
    }

    const clientEntryData = getClientEntryData(opts)
    const clientEntryPath = path.resolve(
      cachePath,
      `./${getEntryFilename('client', md5Hash(clientEntryData))}.js`
    )

    const workerEntryData = getWorkerEntryData()
    const workerEntryPath = path.resolve(
      cachePath,
      `./${getEntryFilename('worker', md5Hash(workerEntryData))}.js`
    )

    await mkdirpPromise(cachePath)
    await fs.promises.writeFile(clientEntryPath, clientEntryData)
    await fs.promises.writeFile(workerEntryPath, workerEntryData)

    const bundlePath = path.resolve(
      cachePath,
      './',
      getBundleFilename(md5Hash(clientEntryData + workerEntryData))
    )

    const compiler = webpack({
      entry: {index: clientEntryPath, worker: workerEntryPath},
      mode: 'production',
      devtool: 'source-map',
      output: {
        path: bundlePath,
        publicPath: '/static/'
      }
    } as import('webpack').Configuration)

    if (onProgress) compiler.apply(new webpack.ProgressPlugin(onProgress))

    compiler.run((err, stats) => {
      if (err) return reject(err)
      return resolve({path: bundlePath, stats})
    })
  })
}

export async function watchBuild(
  cachePath: string,
  opts: BuildOptions,
  onBuild?: (err: Error, stats: WebpackStats) => void,
  onProgress?: (percentage: number, msg: string) => void
) {
  let webpack: typeof import('webpack')

  try {
    webpack = (await import('webpack')).default
  } catch (err) {
    throw new Error("Coulnd't load webpack")
  }

  const clientEntryData = getClientEntryData(opts)
  const clientEntryPath = path.resolve(
    cachePath,
    `./${getEntryFilename('client', md5Hash(clientEntryData))}.js`
  )

  const workerEntryData = getWorkerEntryData()
  const workerEntryPath = path.resolve(
    cachePath,
    `./${getEntryFilename('worker', md5Hash(workerEntryData))}.js`
  )

  await mkdirpPromise(cachePath)
  await fs.promises.writeFile(clientEntryPath, clientEntryData)
  await fs.promises.writeFile(workerEntryPath, workerEntryData)

  const bundlePath = path.resolve(cachePath, './', getBundleFilename(md5Hash(clientEntryData)))

  const compiler = webpack({
    entry: {index: clientEntryPath, worker: workerEntryPath},
    mode: 'development',
    devtool: 'cheap-module-eval-source-map',
    output: {
      path: bundlePath,
      publicPath: '/static/'
    }
  } as import('webpack').Configuration)

  if (onProgress) compiler.apply(new webpack.ProgressPlugin(onProgress))

  compiler.watch({}, (err, stats) => {
    if (onBuild) onBuild(err, stats)
  })

  return bundlePath
}

export function getCachePath() {
  return path.resolve(process.cwd(), '.cache')
}
